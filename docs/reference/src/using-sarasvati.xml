<?xml version='1.0' encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">

<chapter id="using-sarasvati">
  <title>Using Sarasvati</title>


  <section id="using-intro">
    <title>Introduction</title>
    <para>
      Using Sarasvati usually involves writing process definition files, along
      with custom node types. Sarasvati uses an XML file format for
      process definitions. These files can be loaded into in-memory
      graph structures and executed, or they can be loaded first into a
      database, and from there loaded and executed.
   </para>

    <para>
      We first introduce the file format, then explain how to implement
      custom behavior. Finally, we discuss how to interact with the
      Sarasvati engine.
    </para>
  </section>

  <section id="using-file-format">
    <title> Sarasvati File Format</title>

    <section id="using-file-format-intro">
      <title>Introduction </title>
      <para>
        The process definition file format is defined by an XSD, which is
        <ulink url="http://code.google.com/p/sarasvati/source/browse/common/ProcessDefinition.xsd">
          available to view in the project SVN
        </ulink>.
      </para>

      <para>
        We'll explore the Sarasvati file format, starting with the root element
        and working from there, with examples interspersed.
      </para>
    </section>

    <section id="using-process-definition-element">
      <title>Process Definition</title>
      <para>
        This is the root element. It should indicate the XML namespace, that being:
        <literal>http://sarasvati.googlecode.com/ProcessDefinition</literal>
      </para>

      <table frame="all">
        <title><literal>process-definition</literal> attributes</title>
        <tgroup cols="4">
          <thead>
            <row>
              <entry>Attribute Name</entry>
              <entry>Usage</entry>
              <entry>Is Required?</entry>
              <entry>Default Value</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry><literal>name</literal></entry>
              <entry>
                The unique name for this process definition.
              </entry>
              <entry>Yes</entry>
              <entry>N/A</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <table frame="all">
        <title><literal>process-definition</literal> nested elements</title>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Element</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry><literal>node</literal></entry>
              <entry>
                Every <literal>process-definition</literal> must have a least one <literal>node</literal> defined.
              </entry>
            </row>
            <row>
              <entry><literal>external</literal></entry>
              <entry>
                An external declares a process definition to be included. More than one external process definition
                may be included and the same process definition may be included more than once with a different name
                for each include.
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>

    </section>

    <section id="using-node-element">
      <title>Nodes</title>
      <para>
        Nodes in a process definition are defined by the <literal>node</literal>
        element. Every node must have a name <emphasis>unique to that file</emphasis>.
      </para>

      <table frame="all">
        <title><literal>node</literal> attributes</title>
        <tgroup cols="4">
          <thead>
            <row>
              <entry>Attribute Name</entry>
              <entry>Usage</entry>
              <entry>Is Required?</entry>
              <entry>Default Value</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry><literal>name</literal></entry>
              <entry>The name of this node. The name must be unique within this process definition.</entry>
              <entry>Yes</entry>
              <entry>N/A</entry>
            </row>
            <row>
              <entry><literal>type</literal></entry>
              <entry>The node type. Determines the node behavior.</entry>
              <entry>No</entry>
              <entry><literal>node</literal></entry>
            </row>
            <row>
              <entry><literal>isStart</literal></entry>
              <entry>Specifies whether a node will be presented with a token when the process is started.</entry>
              <entry>No</entry>
              <entry><literal>false</literal></entry>
            </row>
            <row>
              <entry><literal>joinType</literal></entry>
              <entry>
                Determines the join strategy the node should use when a token arrives.
                Some nodes may accept incoming tokens as soon as they arrives,
                others may act as gates, waiting until a certain number of
                nodes arrive or token exist on specific incoming arcs before
                executing. See below for the allowed join types.
              </entry>
              <entry>No</entry>
              <entry><literal>or</literal></entry>
            </row>
            <row>
              <entry><literal>joinParam</literal></entry>
              <entry>
                Some join strategies, such as the token set join, may join based on this paramter.
                Alternately, this can be used by the custom join type as the developer desires.
              </entry>
              <entry>No</entry>
              <entry>N/A</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <table frame="all">
        <title><literal>node</literal> nested elements</title>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Element</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry><literal>guard</literal></entry>
              <entry>
                Each node may have a single, optional guard element. The guard is generally defined in the
                Rubric rules language and will be evaluated when the node's join strategy determines that
                the node is to be executed. The guard will determine if the node should be executed, skipped
                or if the newly created node token should be discarded.
              </entry>
            </row>
            <row>
              <entry><literal>arc</literal></entry>
              <entry>
                Nodes may have zero to many arcs, pointing to other nodes in the same process definition. Arcs
                link together nodes and provide the paths along with the flow of execution proceeds.
              </entry>
            </row>
            <row>
              <entry><literal>custom</literal></entry>
              <entry>
                Each node has a custom section which may contain any user defined elements.
                How data from these custom elements is loaded is explained in
                the section on custom node attributes below.
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>
        Every node defines a join strategy, which is invoked when tokens arrive at the node and
        determines when the node is ready to be executed.
      </para>

      <table frame="all">
        <title><literal>node</literal> join types</title>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Type</entry>
              <entry>Behavior</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry><literal>or</literal> </entry>
              <entry>
                An <literal>or</literal> join will be satisfied any time an arc token arrives at the node.
              </entry>
            </row>
            <row>
              <entry><literal>and</literal> </entry>
              <entry>
                An <literal>and</literal> join will be satisfied when an arc token arrives and there are
                arc tokens waiting at all other incoming arcs to the node. In most cases the
                <literal>labelAnd</literal> is safer and more flexible.
              </entry>
            </row>
            <row>
              <entry><literal>labelAnd</literal> </entry>
              <entry>
                A <literal>labelAnd</literal> join will be satisfied when an arc token arrives
                and there are arc tokens waiting at all other incoming arcs to the node which
                share the same name/label as the arc that the arc token is arriving on.
              </entry>
            </row>
            <row>
              <entry><literal>tokenSetAnd</literal> </entry>
              <entry>
                A <literal>tokenSetAnd</literal> join will be satisfied when all active arc tokens
                in the set are on incoming arcs to the same node and there are no active node tokens
                in the token set. An exception will be raised if a non-token set token arrives.
              </entry>
            </row>
            <row>
              <entry><literal>tokenSetOr</literal> </entry>
              <entry>
                A <literal>tokenSetOr</literal> join will be satisfied when all active arc tokens
                in the set are on incoming arcs to the same node and there are no active node tokens
                in the token set. The <literal>or</literal> strategy will be used as a fallback if
                a non-token set token arrives.
              </entry>
            </row>
            <row>
              <entry><literal>custom</literal> </entry>
              <entry>
                Users may use custom join strategies. See the API reference for more detail.
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <section id="using-node-types">
        <title>Built in Node Types</title>
        <itemizedlist>
          <listitem>
            <para>
              <literal>node</literal>
              - Nodes of this type will complete out on the default arc
              when they are executed. The node type can be useful if a
              synchronization point is needed. It can also be used as a
              choice mechanism, by specifying a guard which skips to
              selected arcs.
            </para>
          </listitem>
          <listitem>
            <para>
              <literal>wait</literal>
              - Nodes of this type will enter a wait state when
              executed. They will continue when completed by external
              logic. This can be useful when you need to wait on an
              external event, and no other logic is required.
            </para>
          </listitem>
          <listitem>
            <para>
              <literal>script</literal>
              - Requires a <literal>script</literal> element which will contain a script
              to execute when the node is executed.
            </para>
          </listitem>
        </itemizedlist>

      </section>

      <section id="using-guard">
        <title>Element guard</title>
        <para>
          A node may contain a GuardLang statement, which will be executed as
          the node's guard. The guard element has no attributes and may
          contain no nested elements.
        </para>

      </section>

      <section id="using-one-node-example">
        <title>One Node Example</title>
        <para>
          With just <literal>process-definition</literal>
          and <literal>node</literal> a simple process definition
          can be built.
        </para>

        <para>
          The simplest process definition would be a single node. Graphically,
          it would look like:
        </para>

        <para>
          <informalfigure>
            <graphic fileref="../images/pdfiles/example1.jpg"/>
          </informalfigure>
        </para>

        <para>
          The corresponding XML process definition would look like:
        </para>

        <programlisting><![CDATA[
<?xml version="1.0"?>
<process-definition
  name="simplest"
  xmlns="http://sarasvati.googlecode.com/ProcessDefinition">

  <node name="node-one" isStart="true"/>

</process-definition>
]]></programlisting>

        <para>
          While there can be many nodes declared in a process definition, we have
          as yet, not defined a way of linking them together.
        </para>

      </section>
    </section>

    <section id="using-node-arc-element">
      <title>Node Arcs</title>
      <para>
        An <literal>arc</literal>
        element declares an arc from the enclosing node to the node
        with the name specified in the <literal>to</literal>
        attribute. An arc is allowed no nested elements.
      </para>

      <table frame="all">
        <title><literal>arc</literal> attributes</title>
        <tgroup cols="4">
          <thead>
            <row>
              <entry>Attribute Name</entry>
              <entry>Usage</entry>
              <entry>Is Required?</entry>
              <entry>Default Value</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry><literal>to</literal> </entry>
              <entry>Specifies the name of the node this arc goes to.</entry>
              <entry>Yes</entry>
              <entry>N/A</entry>
            </row>
            <row>
              <entry><literal>name</literal> </entry>
              <entry>Specifies the arc name. This name need not be unique.</entry>
              <entry>No</entry>
              <entry><literal>null</literal></entry>
            </row>
            <row>
              <entry><literal>external</literal> </entry>
              <entry>
                If this arc is linking to an external (see below for more information on externals),
                the name of the external being linked to. If an <literal>external</literal> attribute
                is specified then the <literal>to</literal> attribute will refer to a node in the
                external, not a locally defined node.
              </entry>
              <entry>No</entry>
              <entry><literal>null</literal></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <section id="using-arc-example-one">
        <title>Arc Example One</title>

        <para>
          The following example contains three nodes.
        </para>

        <para>
          <informalfigure>
            <graphic fileref="../images/pdfiles/example2.jpg"/>
          </informalfigure>
        </para>

        <programlisting><![CDATA[<?xml version="1.0"?>
<process-definition
  name="example2"
  xmlns="http://sarasvati.googlecode.com/ProcessDefinition">

  <node name="node-one" isStart="true">
    <arc to="node-two"/>
    <arc to="node-three"/>
  </node>

  <node name="node-two"/>
  <node name="node-three"/>

</process-definition>
]]></programlisting>

        <para>
          To indicate an arc, an
          <literal>arc</literal>
          element is added to the start node. The
          <literal>to</literal>
          attribute indicates the name of the target node. A node with
          that name must exist in the same process definition file.
        </para>

      </section>

      <section id="using-arc-example-two">
        <title>Arc Example Two </title>

        <para>
          Here is an example with two start nodes. They both have arcs
          to
          <literal>node-three</literal>
          , which uses the <literal>labelAnd</literal> join strategy. It will only execute once both
          <literal>node-one</literal>
          and
          <literal>node-two</literal>
          have completed.
        </para>

        <para>
          <informalfigure>
            <graphic fileref="../images/pdfiles/example3.jpg"/>
          </informalfigure>
        </para>

        <programlisting><![CDATA[<?xml version="1.0"?>
<process-definition
  name="example3"
  xmlns="http://sarasvati.googlecode.com/ProcessDefinition">

  <node name="node-one" isStart="true">
    <arc to="node-three"/>
  </node>

  <node name="node-two" isStart="true">
    <arc to="node-three"/>
  </node>

  <node name="node-three" joinType="labelAnd"/>

</process-definition>
]]></programlisting>

        <para>
          Now that we've seen how to create links between nodes in the same
          process definition, let us examine how to include external process
          definitions and create links to them.
        </para>

      </section>
    </section>

    <section id="using-external-element">
      <title>Externals</title>
      <para>
        An exernal process definition must have a declaration for each time
        it is to be included.
      </para>

      <table frame="all">
        <title><literal>external</literal> attributes</title>
        <tgroup cols="4">
          <thead>
            <row>
              <entry>Attribute Name</entry>
              <entry>Usage</entry>
              <entry>Is Required?</entry>
              <entry>Default Value</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry><literal>name</literal></entry>
              <entry>
                The name by which this external process definition will be referred to.
                The name must be unique within this process definition.
              </entry>
              <entry>Yes</entry>
              <entry>N/A</entry>
            </row>
            <row>
              <entry><literal>processDefinition</literal></entry>
              <entry>
                The name of the process definition being included. The same process definition
                may be included more than once.
              </entry>
              <entry>Yes</entry>
              <entry>N/A</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <table frame="all">
        <title><literal>external</literal> nested elements</title>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Element</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry><literal>arc</literal></entry>
              <entry>
                Externals may have zero to many arcs. The arcs originate in the extenal process definition.
                They may end in nodes in the same process definition, in other externals or even in
                the same external.
              </entry>
            </row>
            <row>
              <entry><literal>custom</literal></entry>
              <entry>
                Each external has a custom section which may contain any user defined elements.
                How data from these custom elements is made loaded is explained in
                the section on custom external attributes below.
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>

    </section>

    <section id="using-external-arc-element">
      <title>External arcs</title>
      <para>
        An <literal>arc</literal> element in an <literal>external</literal> declares an arc
        from a node in the enclosing external to the node with the name specified in
        the <literal>to</literal> attribute. An arc is allowed no nested elements.
      </para>

      <table frame="all">
        <title><literal>arc</literal> attributes</title>
        <tgroup cols="4">
          <thead>
            <row>
              <entry>Attribute Name</entry>
              <entry>Usage</entry>
              <entry>Is Required?</entry>
              <entry>Default Value</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry><literal>from</literal> </entry>
              <entry>Specifies the name of the node in the external that this arc starts from.</entry>
              <entry>Yes</entry>
              <entry>N/A</entry>
            </row>
            <row>
              <entry><literal>to</literal> </entry>
              <entry>Specifies the name of the node this arc goes to.</entry>
              <entry>Yes</entry>
              <entry>N/A</entry>
            </row>
            <row>
              <entry><literal>name</literal> </entry>
              <entry>Specifies the arc name. This name need not be unique.</entry>
              <entry>No</entry>
              <entry><literal>null</literal></entry>
            </row>
            <row>
              <entry><literal>external</literal> </entry>
              <entry>
                If this arc is linking to another external, this specifies the name of the external
                being linked to. If an <literal>external</literal> attribute is specified then the
                <literal>to</literal> attribute will refer to a node in the external, not a locally
                defined node.
              </entry>
              <entry>No</entry>
              <entry><literal>null</literal></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <section id="using-external-arc-example-one">
        <title>External Arc Example One </title>
        <para>
          To examine external arcs, we'll need at least two process
          definitions.
        </para>

        <para>
          This example is from the EngineConcepts section.
        </para>

        <programlisting><![CDATA[<?xml version="1.0"?>
<process-definition
  name="ext"
  xmlns="http://sarasvati.googlecode.com/ProcessDefinition">

  <node name="A" joinType="labelAnd">
    <arc to="B"/>
  </node>

  <node name="B" joinType="labelAnd"/>

</process-definition>
]]></programlisting>

        <para>
          It looks like:

          <informalfigure>
            <graphic fileref="../images/concepts-externals1.jpg"/>
          </informalfigure>

          The graph which contains external arcs going to 'ext', is below.
        </para>

        <programlisting><![CDATA[<?xml version="1.0"?>
<process-definition
  name="example4"
  xmlns="http://sarasvati.googlecode.com/ProcessDefinition">

  <node name="P" isStart="true">
    <arc external="1" to="A"/>
  </node>

  <node name="Q" isStart="true">
    <arc external="2" to="A"/>
  </node>

  <node name="R" isStart="true">
    <arc external="2" to="B"/>
  </node>

  <node name="X">
    <arc to="Z"/>
  </node>

  <node name="Y">
    <arc to="Z"/>
  </node>

  <node name="Z" joinType="labelAnd"/>

  <external name="1" processDefinition="ext">
    <arc from="A" to="X"/>
  </external>

  <external name="2" processDefinition="ext">
    <arc from="B" to="Y"/>
  </external>

</process-definition>
]]></programlisting>

        <para>
          It looks like:

          <informalfigure>
            <graphic fileref="../images/concepts-externals4.jpg" scalefit="1" width="100%"/>
          </informalfigure>

          When the process definition is loaded into memory, it will look like:

          <informalfigure>
            <graphic fileref="../images/concepts-externals5.jpg" scalefit="1" width="100%"/>
          </informalfigure>

          The process definition file format also supports custom elements and
          attributes, but before we discuss that, the API needs to be
          introduced.
        </para>
      </section>
    </section>
  </section>
  <section id="using-api-engine">
    <title>The Sarasvati Engine</title>
    <para>
      Almost all interaction with the Sarasvati will involve an instance of an
      <ulink url="../../javadoc/com/googlecode/sarasvati/Engine.html">Engine</ulink>
      in some way.
    </para>
    <para>
      An engine instance does the work of executing process definintions as well as
      providing access to other APIs, such as the loader.
    </para>
    <para>
      Sarasvati supports multiple backends, and is packaged with two. Each backend
      will provide its own <literal>Engine</literal> impementation.

      <table frame="all">
        <title>Engine Implementations</title>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Name</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>MemEngine</entry>
              <entry>
                This engine runs only in memory. Workflows must be loaded everytime the
                JVM starts up. Processes will only survive as long as the JVM is running.
                Since no database accesses are done, this implementation should provide
                the best performance.
              </entry>
            </row>
            <row>
              <entry>HibEngine</entry>
              <entry>
                This engine stores process definitions and the state of processes in
                a database. Communication with the database is handled using Hibernate.
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      Creating a new <literal>MemEngine</literal> is straightforward.
      <programlisting><![CDATA[
  MemEngine engine = new MemEngine();
      ]]></programlisting>

      Creating a new <literal>HibEngine</literal> is only slightly more complicated.
      It requires a Hibernate <literal>Session</literal> in order to function.
      <programlisting><![CDATA[
  HibEngine engine = new HibEngine( session );

  // alternately, the session can be set
  // after construction
  HibEngine engine = new HibEngine();
  engine.setSession( session );
      ]]></programlisting>
    </para>
  </section>

  <section id="using-api-loading">
    <title>Loading Process Definitions</title>
    <para>
      Before a process definition can be executed, it must be loaded into memory,
      and potentially combined with referenced externals.
      This is a two step process.
      <orderedlist>
        <listitem>
          First the process definition is loaded in an instance of
          <ulink url="../../javadoc/com/googlecode/sarasvati/load/ProcessDefinition.html">ProcessDefinition</ulink>.
          This instance maps directly to the XML process definition format.
        </listitem>
        <listitem>
          Next, the <literal>ProcessDefinition</literal> is transformed into an instance of
          <ulink url="../../javadoc/com/googlecode/sarasvati/Graph.html">Graph</ulink>. If
          the process definition has externals defined, these must already be loaded and
          will be imported into the new <literal>Graph</literal>.
        </listitem>
      </orderedlist>

      Loading is done by an instance of
      <ulink url="../../javadoc/com/googlecode/sarasvati/load/GraphLoader.html">GraphLoader</ulink>.
      Instances of <literal>GraphLoader</literal> can be acquired from an <literal>Engine</literal>
      instance. When a process definition is loaded, it will be loaded into a
      <ulink url="../../javadoc/com/googlecode/sarasvati/load/GraphRepository.html">GraphRepository</ulink>
      associated with the <literal>Engine</literal>.
    </para>
    <para>
      There are various ways that process definitions can be loaded. The easiest is to load a single
      file. Let us assume that process definitions are stored in <literal>./process-definitions/</literal>,
      and we wish to load the <literal>test</literal> process definition.

      <programlisting><![CDATA[
  MemEngine engine = new MemEngine();
  GraphLoader<?> loader = engine.getLoader();
  loader.load( new File( "./process-definitions/test.wf.xml" ) );
  Graph graph = engine.getRepository().getLatestGraph( "test" );
  GraphProcess process = engine.startProcess( graph );

        /* alternately */
  MemEngine engine = new MemEngine();
  engine.getLoader().load( new File( "./process-definitions/test.wf.xml" ) );
  GraphProcess process = engine.startProcess( "test" );
      ]]></programlisting>

      If <literal>test</literal> has dependencies, and those dependencies are not yet
      loaded, this load will fail. <literal>GraphLoader</literal> also has a method
      to allow loading a process definition along with any dependencies that haven't
      been loaded yet, or have changed. A SHA-1 hash is used to calculate if a
      process definition has changed. This is stored in the <literal>customId</literal>
      property of <literal>Graph</literal>.

      <programlisting><![CDATA[
  MemEngine engine = new MemEngine();
  XmlLoader loader = new XmlLoader();

  File basePath = new File( "./process-definitions" );
  ProcessDefinitionResolver resolver =
    new DefaultFileXmlProcessDefinitionResolver( xmlLoader, basePath );

  engine.getLoader().loadWithDependencies( "test", resolver );
  GraphProcess process = engine.startProcess( "test" );
      ]]></programlisting>

      Finally, it's often desirable to load an entire set of process definitions,
      or at least those that are new or require updates. This can be done as
      follows:

      <programlisting><![CDATA[
  MemEngine engine = new MemEngine();
  File basePath = new File( "./process-definitions" );
  engine.getLoader().loadNewAndChanged( new File( basePath ) );
  GraphProcess process = engine.startProcess( "test" );
      ]]></programlisting>

    </para>

    <section id="using-java-api-interfaces">
      <title>Interfaces</title>
      <para>
        The main interface for interacting with process definitions and processes is
        <ulink url="../../javadoc/com/googlecode/sarasvati/Engine.html">Engine</ulink>.
      </para>

      <programlisting><![CDATA[package com.googlecode.sarasvati;
public interface Engine
{
  GraphProcess startProcess (Graph graph);
  void startProcess (GraphProcess process);
  void cancelProcess (GraphProcess process);
  void finalizeComplete (GraphProcess process);
  void finalizeCancel (GraphProcess process);
  void completeExecution (NodeToken token, String arcName);
  void completeAsynchronous (NodeToken token, String arcName );
  void executeQueuedArcTokens (GraphProcess process);
  GraphRepository<? extends Graph> getRepository ();
  GraphFactory<? extends Graph> getFactory ();
  GraphLoader<? extends Graph> getLoader ();
  void addNodeType (String type, Class<? extends Node> nodeClass );
  void fireEvent (ExecutionEvent event);
  void addExecutionListener (ExecutionListener listener, ExecutionEventType...eventTypes);
  void addExecutionListener (GraphProcess process, ExecutionListener listener, ExecutionEventType...eventTypes);
  void removeExecutionListener (ExecutionListener listener, ExecutionEventType...eventTypes);
  void removeExecutionListener (GraphProcess process, ExecutionListener listener, ExecutionEventType...eventTypes);
  ExecutionListener getExecutionListenerInstance (String type) throws WorkflowException;
  void setupScriptEnv (ScriptEnv env, NodeToken token);
}
]]></programlisting>

      <para>
        Process definitions are stored in classes implementing the
        <literal>Graph</literal>
        interface.
      </para>

      <programlisting><![CDATA[package com.googlecode.sarasvati;

public interface Graph
{
  String getName ();
  int getVersion ();
  List<? extends Arc> getArcs ();
  List<? extends Arc> getInputArcs (Node node);
  List<? extends Arc> getInputArcs (Node node, String arcName);
  List<? extends Arc> getOutputArcs (Node node);
  List<? extends Arc> getOutputArcs (Node node, String arcName);
  List<? extends Node> getStartNodes ();
  List<? extends Node> getNodes ();
}
]]></programlisting>

      <para>
        A <literal>Graph</literal> contains instances of
        <literal>Node</literal> and <literal>Arc</literal>.
      </para>

      <para>
        <literal>Node</literal> is where the developer can provide custom
        functionality, and has the following API:
      </para>

      <programlisting><![CDATA[package com.googlecode.sarasvati;
public interface Node extends Adaptable
{
  String getName ();
  String getType ();
  boolean isJoin ();
  boolean isStart ();
  String getGuard ();
  Graph getGraph ();
  boolean isExternal ();
  GuardResponse guard (Engine engine, NodeToken token);
  void execute (Engine engine, NodeToken token);
}
]]></programlisting>

    </section>
    <section id="using-flow-of-execution">
      <title>Flow of Execution</title>
      <para>
        When the engine determines that a node is ready to execute, it will
        follow this flow:
      </para>

      <orderedlist>
        <listitem>
          Generate a <literal>NodeToken</literal> pointing to that node.
        </listitem>
        <listitem>
          Execute the <literal>guard</literal> function on the node. This will return a
          <literal>GuardResponse</literal>.
          <itemizedlist>
            <listitem>
              The <literal>GuardResponse</literal> contains a <literal>GuardAction</literal>,
              which is an enum having values <literal>AcceptToken</literal>,
              <literal>DiscardToken</literal> and <literal>SkipNode</literal>.
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          If the action is <literal>AcceptToken</literal>, the <literal>execute</literal>
          method will be called. The process will not continue until the
          <literal>Engine#completeExecution</literal> method is invoked. It must be
          invoked with the name of the arcs on which to generate <literal>ArcToken</literal>s.
        </listitem>
        <listitem>
          If the action is <literal>DiscardToken</literal>, the token is marked complete
          and no further execution will take place from this set of tokens.
        </listitem>
        <listitem>
          If the action is <literal>SkipNode</literal>, <literal>Engine.completeExecution</literal>
          will be called with the arc name contained in the <literal>GuardResponse</literal>.
        </listitem>
      </orderedlist>
    </section>

    <section id="using-custom-logic-node-execution">
      <title>Custom logic for Node Execution</title>
      <para>
        To provide custom behavior to your nodes, you will override the
        <literal>execute</literal>
        method on
        <literal>Node</literal>
        . Sarasvati currently provides two implementations of the base
        API, one memory backed and one database backed, implemented
        using Hibernate. Other implementations could be made using, for
        example, pure JDBC or some other persistence mechanism. There
        are three base classes for nodes.
      </para>

      <itemizedlist>
        <listitem>
          <para>
            <literal>com.googlecode.sarasvati.mem.MemNode</literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>com.googlecode.sarasvati.hib.HibNode</literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>com.googlecode.sarasvati.CustomNode</literal>
          </para>
        </listitem>
      </itemizedlist>

      <para>
        If using only the memory backed implementation,
        <literal>MemNode</literal>
        should be extended. If using only the hibernate backend, nodes
        should subclass <literal>HibNode</literal>.
        <literal>CustomNode</literal>
        can be used with either or both backends. In to store custom
        attributes in the database, it uses a key/value pair table.
        <literal>CustomNode</literal>
        can only be used if the database mapping doesn't need to be
        explicitly defined.
      </para>

      <section id="using-custom-example-one">
        <title>Example One </title>
        <para>
          To demonstrate use of each implementation, we start with a node that
          just prints out "Hello, World". We start with the process
          definition.
        </para>

        <section id="using-custom-example-one-proc-def">
          <title>Example One: Process Definition </title>
          <programlisting><![CDATA[<?xml version="1.0"?>
<process-definition
  name="hello-world"
  xmlns="http://sarasvati.googlecode.com/ProcessDefinition">

  <node name="hello" type="helloWorld" isStart="true"/>

</process-definition>
]]></programlisting>

        </section>
        <section id="using-custom-example-one-node-impl">
          <title>Example One: Node implementation </title>
          <para>
            If using the memory implementation, the subclass would look like:
          </para>

          <programlisting><![CDATA[
package com.googlecode.sarasvati.example.mem;

import com.googlecode.sarasvati.Arc;
import com.googlecode.sarasvati.Engine;
import com.googlecode.sarasvati.NodeToken;
import com.googlecode.sarasvati.mem.MemNode;

public class HelloNode extends MemNode
{
  @Override
  public void execute (Engine engine, NodeToken token)
  {
    System.out.println( "Hello, world!" );
    engine.completeExecution( token, Arc.DEFAULT_ARC );
  }
}
]]></programlisting>

          <para>
            The hibernate version would look like:
          </para>

          <programlisting><![CDATA[
import javax.persistence.DiscriminatorValue;
import javax.persistence.Entity;

import com.googlecode.sarasvati.Arc;
import com.googlecode.sarasvati.Engine;
import com.googlecode.sarasvati.NodeToken;
import com.googlecode.sarasvati.hib.HibNode;

@Entity
@DiscriminatorValue( "helloWorld" )
public class HelloNode extends HibNode
{
  @Override
  public void execute (Engine engine, NodeToken token)
  {
    System.out.println( "Hello, World!" );
    engine.completeExecution( token, Arc.DEFAULT_ARC );
  }
}
]]></programlisting>

          <para>
            The hibernate version would also require an insert into the
            <literal>wf_node_type</literal> table, with type, description
            and behaviour. As of 1.0.0-rc3, Sarasvati will insert the
            node type into the database if it's missing. However,
            manually inserted the node type will not hurt anything.
          </para>

          <programlisting><![CDATA[
insert into wf_node_type (id, description, behaviour)
 values ( 'helloWorld', 'Says hello to the world', 'helloWorld' )
]]></programlisting>

          <para>
            The behaviour column ties the type to a discriminator specified on the
            subclass. This allows having multiple types with the same
            implementation class, if that was desired.
          </para>

          <para>
            The backend independent version would look like:
          </para>

          <programlisting><![CDATA[
import com.googlecode.sarasvati.Arc;
import com.googlecode.sarasvati.CustomNode;
import com.googlecode.sarasvati.Engine;
import com.googlecode.sarasvati.NodeToken;

public class HelloNode extends CustomNode
{
  @Override
  public void execute (Engine engine, NodeToken token)
  {
    System.out.println( "Hello, World!" );
    engine.completeExecution( token, Arc.DEFAULT_ARC );
  }
}
]]></programlisting>

          <para>
            For use with the hibernate backend, a row would still need to be
            added to the <literal>wf_node_type</literal> table.
          </para>

          <programlisting><![CDATA[
insert into wf_node_type (id, description, behaviour)
 values ( 'helloWorld', 'Says hello to the world', 'custom' )
]]></programlisting>

        </section>
        <section id="using-example-one-load-run">
          <title>Example One: Loading and Running</title>
          <para>
            Now we can load the process into memory, or into the database.
            This is done using a <literal>GraphLoader</literal>, which can
            be retrieved from the appropriate engine. Before loading the
            process definition, you will need to tell the engine about your
            custom node types.
          </para>

          <para>
            The steps are
            <orderedlist>
              <listitem>
                <para>
                  Create an engine of the appropriate type
                </para>
              </listitem>
              <listitem>
                <para>
                  Register custom node types
                </para>
              </listitem>
              <listitem>
                <para>
                  Load the process definition from XML file
                </para>
              </listitem>
              <listitem>
                <para>
                  Get the loaded graph from the graph repository associated with the
                  engine
                </para>
              </listitem>
              <listitem>
                <para>
                  Start a new GraphProcess using the graph
                </para>
              </listitem>
            </orderedlist>

            Here are the steps in code for the memory backed implementation.
          </para>

          <programlisting><![CDATA[
    MemEngine engine = new MemEngine();

    // Tell engine about our custom node type
    engine.addNodeType( "helloWorld", HelloNode.class );

    // Load the process definition (this can throw LoadException or JAXBException
    // The graph will be stored in the GraphRepository for this engine
    engine.getLoader().load( "/path/to/hello-world.wf.xml" );

    // Get the graph from the GraphRepository
    Graph graph = engine.getRepository().getLatestGraph( "hello-world" );

    // start a graph process
    GraphProcess process = engine.startProcess( graph );
]]></programlisting>

          <para>
            Here are the steps in code for the hibernate backed
            implementation. It assumes that you have a means of creating a
            hibernate <literal>Session</literal> object.
          </para>

          <programlisting><![CDATA[
    Session session = ...; // get hibernate session
    HibEngine engine = new HibEngine( session );

    // Tell engine about our custom node type
    engine.addNodeType( "helloWorld", HelloNode.class );

    // Load the process definition (this can throw LoadException or JAXBException
    // The graph will be stored in the GraphRepository for this engine
    engine.getLoader().load( "/path/to/hello-world.wf.xml" );

    // Get the graph from the GraphRepository
    Graph graph = engine.getRepository().getLatestGraph( "hello-world" );

    // start a graph process
    GraphProcess process = engine.startProcess( graph );
]]></programlisting>

          <para>
            Here are the steps in code using the backend independent custom
            type with <literal>MemEngine</literal>.
          </para>

          <programlisting><![CDATA[
    MemEngine engine = new MemEngine();

    // We can either register the type with the Engine or with the DefaultNodeFactory
    // directly.
    // Either tell the engine about our custom node type
    engine.addGlobalCustomNodeType( "helloWorld", HelloNode.class );

    // or tell the DefaultNodeFactory about the node type directly
    DefaultNodeFactory.addGlobalCustomType( "helloWorld", HelloNode.class );

    // Load the process definition (this can throw LoadException or JAXBException
    // The graph will be stored in the GraphRepository for this engine
    engine.getLoader().load( "/path/to/hello-world.wf.xml" );

    // Get the graph from the GraphRepository
    Graph graph = engine.getRepository().getLatestGraph( "hello-world" );

    // start a graph process
    GraphProcess process = engine.startProcess( graph );
]]></programlisting>


          <para>
            The call to <literal>startProcess</literal>
            will create tokens on the start nodes and will continue
            executing the process until it completes or enters a wait state.
          </para>

        </section>
      </section>
    </section>
    <section id="using-custom-attributes">
      <title>Custom Attributes</title>
      <para>
        Often, custom nodes will need some information with which to do their
        work. Sarasvati supports this in two ways.
      </para>

      <para>
        The schema for process definition files has a
        <literal>&lt;custom&gt;</literal>
        element which contains an
        <literal>&lt;xs:any&gt;</literal>
        element at the end of the node definition. Custom elements may
        be added here. These can be automatically mapped to properties
        on custom nodes.
      </para>

      <para>
        For example, given the following custom node:
      </para>

      <programlisting><![CDATA[
public class CustomNode extends MemNode
{
  String foo;

  public String getFoo ()
  {
    return foo;
  }

  public void setFoo (String foo)
  {
    this.foo = foo;
  }

  @Override
  public void execute (Engine engine, NodeToken token)
  {
    // do something ...
    engine.completeExecution( token, Arc.DEFAULT_ARC );
  }
}
]]></programlisting>

      <para>
        The following process definition would load the value
        <literal>test</literal> into the <literal>custom</literal>
        property.
      </para>

      <programlisting><![CDATA[
<?xml version="1.0"?>
<process-definition
  name="example1"
  xmlns="http://sarasvati.googlecode.com/ProcessDefinition">

  <node name="test" type="custom" isStart="true">
    <arc to="1"/>

    <custom>
      <foo>test</foo>
    </custom>
  </node>
</process-definition>
]]></programlisting>

      <para>
        There several things to note with custom elements.
      </para>

      <itemizedlist>
        <listitem>
          <para>
            All custom elements must be contained within the
            <literal>&lt;custom&gt;</literal> tag.
          </para>
        </listitem>
        <listitem>
          <para>
            Non-string properties on custom node types are supported.
          </para>
          <itemizedlist>
            <listitem>
              <para>
                Support for primitive types such as boolean, byte, char, short, int,
                long, float, double as well as their corresponding
                object types is built in.
          </para>
            </listitem>
            <listitem>
              <para>
                Support for non-primitive types can be added
          </para>
              <itemizedlist>
                <listitem>
                  <para>
                    Implement <literal>com.googlecode.sarasvati.env.AttributeConverter</literal>
                  </para>
                </listitem>
                <listitem>
                  <para>
                    Register the new mutator using the <literal>setConverterForType</literal>
                    method (which takes a class and an <literal>AttributeConverter</literal>)
                    on <literal>com.googlecode.sarasvati.env.AttributeConverters</literal>.
                  </para>
                </listitem>
              </itemizedlist>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>

      <para>
        Nested objects are supported. For example:
      </para>

      <programlisting><![CDATA[
  <custom>
    <task>
      <name>test</name>
    </task>
  </custom>
]]></programlisting>

      <para>
        The loader would invoke <literal>getTask().setName( ... )</literal>
        on the custom node.
      </para>

      <para>
        Attributes are also supported. How they are mapped is based on the contents of
        the element the attribute is on. If the element has child
        elements, the attribute will get mapped as a child property. If
        the element is itself a property, the attribute name will be
        combined with the element name to get the property name.
      </para>

      <programlisting><![CDATA[
  <custom>
    <task user="pat">
      <name>test</name>
    </task>
  </custom>
]]></programlisting>

      <para>
        This would map the
        <literal>name</literal>
        element value to
        <literal>getTask().setName( ... )</literal>
        and the
        <literal>user</literal>
        attribute to
        <literal>getTask().setUser( ... )</literal>
        .
      </para>

      <para>
        However, the following would be mapped differently:
      </para>

      <programlisting><![CDATA[
  <custom>
    <task user="pat">
      test
    </task>
  </custom>
]]></programlisting>

      <para>
        This would map the text in the
        <literal>task</literal>
        element to
        <literal>setTask( ... )</literal>
        and the
        <literal>user</literal>
        attribute to
        <literal>setTaskUser( ... )</literal>
        .
      </para>

    </section>
    <section id="using-java-api-custom-loader">
      <title>Custom Loader</title>
      <para>
        You may also provide custom loading via a subclass of
        <literal>NodeFactory</literal>. It has the following interface:
      </para>

      <programlisting><![CDATA[
public interface NodeFactory
{
  Node newNode (String type) throws LoadException;
  void loadCustom (Node node, Object custom) throws LoadException;
}
]]></programlisting>

      <para>
        The custom data may be null, a single object, or a list of
        objects. The object or objects will either be elements of
        <literal>org.w3c.dom.Element</literal>
        or JAXB objects, if you have a JAXB mapping for your custom XML.
      </para>

      <para>
        Instances of
        <literal>NodeFactory</literal>
        may be registered on
        <literal>GraphLoader</literal>
        .
      </para>

      <section id="using-example-two-proc-def">
        <title>Example Two: Process Definition </title>

        <para>
          Here we examine a more complicated example, which uses custom
          attributes.
       </para>

        <programlisting><![CDATA[<?xml version="1.0"?>

<process-definition
  name="example1"
  xmlns="http://sarasvati.googlecode.com/ProcessDefinition">

  <node name="start" isStart="true">
    <arc to="1"/>
  </node>

  <node name="1" type="task">
    <arc to="2"/>
    <arc to="3"/>

    <custom>
      <taskName>Enter order</taskName>
      <taskDesc>
        Enter order and billing info
      </taskDesc>
    </custom>
  </node>

  <node type="task" name="2">
    <arc to="4"/>

    <custom>
      <taskName>Bill Customer</taskName>
      <taskDesc>
        Bill the Customer
      </taskDesc>
    </custom>
  </node>

  <node type="task" name="3">
    <arc to="4"/>

    <custom>
      <taskName>Ship product</taskName>
      <taskDesc>
        Package and ship product
      </taskDesc>
    </custom>
  </node>

  <node type="task" name="4" joinType="labelAnd">

    <custom>
      <taskName>Market to Customer</taskName>
      <taskDesc>
        Send marketing material to customer
      </taskDesc>
    </custom>

  </node>

</process-definition>
]]></programlisting>

      </section>
      <section id="using-example-two-node-impl">
        <title>Example Two: Node implementation </title>

        <para>
          We will need a couple of classes to represent tasks and their state.
          First we look at the memory based implementation.
        </para>

        <para>
          First we have an enum for task states.
          <programlisting><![CDATA[
public enum TaskState { Open, Completed, Rejected }
]]></programlisting>

          Next is the <literal>Task</literal> class.
        </para>

        <programlisting><![CDATA[
public class Task
{
  protected NodeToken nodeToken;
  protected String name;
  protected String description;
  protected TaskState state;

  public Task (NodeToken nodeToken, String name, String description, TaskState state)
  {
    this.nodeToken = nodeToken;
    this.name = name;
    this.description = description;
    this.state = state;
  }

  public NodeToken getNodeToken ()
  {
    return nodeToken;
  }

  public void setNodeToken (NodeToken nodeToken)
  {
    this.nodeToken = nodeToken;
  }

  public String getName ()
  {
    return name;
  }

  public String getDescription ()
  {
    return description;
  }

  public TaskState getState ()
  {
    return state;
  }

  public void setState (TaskState state )
  {
    this.state = state;
  }

  public boolean isRejectable ()
  {
    Node node = getNodeToken().getNode();
    return !node.getGraph().getOutputArcs( node, "reject" ).isEmpty();
  }
}
]]></programlisting>

        <para>
          In our simple example, we need some way of tracking which tasks have
          been created.
        </para>

        <programlisting><![CDATA[
public class TaskList
{
  protected static List<Task> tasks = new LinkedList<Task>();

  public static List<Task> getTasks ()
  {
    return tasks;
  }
}
]]></programlisting>

        <para>
          Finally, the custom node for generating tasks
        </para>

        <programlisting><![CDATA[
public class TaskNode extends MemNode
{
  protected String taskName;
  protected String taskDesc;

  public String getTaskName ()
  {
    return taskName;
  }

  public void setTaskName (String taskName)
  {
    this.taskName = taskName;
  }

  public String getTaskDesc ()
  {
    return taskDesc;
  }

  public void setTaskDesc (String taskDesc)
  {
    this.taskDesc = taskDesc;
  }

  @Override
  public void execute (Engine engine, NodeToken token)
  {
    Task newTask = new Task( token, getTaskName(), getTaskDesc(), TaskState.Open );
    TaskList.getTasks().add( newTask );
  }
}
]]></programlisting>

        <para>
          When a task node is executed, it will create new
          <literal>Task</literal>
          instance and add it to a task list. A task can be completed or
          rejected as seen in the following code snippet:
        </para>

        <programlisting><![CDATA[
      Task t = ...;

      if ( isCompletion )
      {
        t.setState( TaskState.Completed );
        engine.completeExecution( t.getNodeToken(), Arc.DEFAULT_ARC );
      }
      else if ( isReject && t.isRejectable() )
      {
        t.setState( TaskState.Rejected );
        engine.completeExecution( t.getNodeToken(), "reject" );
      }
]]></programlisting>

        <para>
          The primary difference with the database/Hibernate version, is
          that the node and tasks will require database backing. Let us
          look at the <literal>TaskNode</literal> class.
        </para>

        <programlisting><![CDATA[
@Entity
@DiscriminatorValue( "task" )
@SecondaryTable( name="wf_node_task", pkJoinColumns=@PrimaryKeyJoinColumn(name="id"))
public class TaskNode extends HibNode
{
  @Column (name="name", table="wf_node_task")
  protected String taskName;

  @Column (name="description", table="wf_node_task")
  protected String taskDesc;

  public TaskNode() { /* Default constructor for Hibernate */ }

  public String getTaskName ()
  {
    return taskName;
  }

  public void setTaskName (String taskName)
  {
    this.taskName = taskName;
  }

  public String getTaskDesc ()
  {
    return taskDesc;
  }

  public void setTaskDesc (String taskDesc)
  {
    this.taskDesc = taskDesc;
  }

  @Override
  public void execute (Engine engine, NodeToken token)
  {
    HibEngine hibEngine = (HibEngine)engine;

    Session session = hibEngine.getSession();

    TaskState open = (TaskState)session.load( TaskState.class, 0 );
    Task newTask = new Task( (HibNodeToken)token, getTaskName(), getTaskDesc(), open );
    session.save( newTask );
  }
}
]]></programlisting>


      </section>
    </section>

    <section id="using-java-api-env">
      <title>Environment</title>
      <para>
        It is often useful to track state associated with a process or tokens. Sarasvati
        provides several environments in which state can be placed. Some environments
        are defined solely by the contents of a process definition, and are therefore
        readonly. Readonly environments are represented by the
        <ulink url="../../javadoc/com/googlecode/sarasvati/env/ReadEnv.html">ReadEnv</ulink>
        interface. Most environments are read-write and are represented by the
        <ulink url="../../javadoc/com/googlecode/sarasvati/env/Env.html">Env</ulink> interface,
        which extends from <literal>ReadEnv</literal>.
      </para>

      <para>
        The Env interface supports both persistent and transient attributes.

        <table frame="all">
          <title>Environment Attribute Types</title>
          <tgroup cols="2">
            <colspec colnum="1" colwidth="60"/>
            <thead>
              <row>
                <entry>Type</entry>
                <entry>Behavior</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>Persistent</entry>
                <entry>
                  Must be serializable to the database. All primitives and object version of the primitives, as
                  well as String and Date are supported by default. Support for other types may be added
                  by defining an <ulink url="../../javadoc/com/googlecode/sarasvati/env/AttributeConverter.html">AttributeConverter</ulink>,
                  which is then registered with the
                  <ulink url="../../javadoc/com/googlecode/sarasvati/env/AttributeConverters.html">AttributeConverters</ulink> class,
                  using the <literal>setConverterForType</literal> method.
                </entry>
              </row>
              <row>
                <entry>Transient</entry>
                <entry>
                  Transient attributes are only stored as long as the process is in memory. They are a convenient places to cache values
                  during process execution. Because they aren't persisted to a database, there is no restriction on what types can
                  be stored.
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </para>

      <section id="using-java-api-env-process">
        <title>Process Environment</title>
        <para>
          A process environment is read-write and is shared across an entire process.
        </para>

         <programlisting><![CDATA[
  GraphProcess p = ...;
  Env env = p.getEnv();
  env.setAttribute( "foo", "test" );
  env.setAttribute( "bar", 5 );
  String foo = env.getAttribute( "foo" );
  int bar = env.getAttribute( "foo", Integer.class );
           ]]>
         </programlisting>
      </section>

      <section id="using-java-api-env-token">
        <title>Node Token Environment</title>
        <para>
          The node token environment is read-write. Node token state is only visible to the
          given token, however tokens inherit the environment of their parents. Token state
          is initialized using the following rules:

          <itemizedlist>
            <listitem>
             <para>
               If a token has no parents, it will start with an empty environment.
             </para>
            </listitem>
            <listitem>
             <para>
               If a token has one parent, it will inherit the environment of its parent.
             </para>
            </listitem>
            <listitem>
             <para>
               When a child token inherits the environment of it's parent, it may point directly
               to the parent's environment, until the child writes to the environment, at which
               point the environment will be copied. This means that if the parents writes to the
               environment after children have been created, and the children have not written
               to their environments, these changes will be visible to the children.
             </para>
            </listitem>
            <listitem>
             <para>
               If a token has multiple parents parent, it will inherit the environment of its parent.
             </para>
            </listitem>
            <listitem>
             <para>
               If a token has multiple parents parent with overlapping attribute names, the child
               environment wil get one the value from one of the parents, generally whichever is
               merged into the child environment last.
             </para>
            </listitem>

          </itemizedlist>
        </para>

         <programlisting><![CDATA[
  NodeToken t = ...;
  Env env = t.getEnv();
  env.setAttribute( "foo", "test" );
  env.setAttribute( "bar", 5 );
  String foo = env.getAttribute( "foo" );
  int bar = env.getAttribute( "foo", Integer.class );
]]>
         </programlisting>
      </section>
      <section id="using-java-api-env-combining">
        <title>Combining Environment</title>
        <para>
          To read from both the process and node token environments, use the
          <literal>NodeToken#getFullEnv()</literal> method. It will return
          an <literal>Env</literal> which will read first from node token environment
          and, if no attribute is defined there, read from the process environment.
          All writes will affect the node token environment.
        </para>
        <para>
          This is implemented using
          <ulink url="../../javadoc/com/googlecode/sarasvati/impl/NestedEnv.html">NestedEnv</ulink>,
          which can be used to stack any combination of environments.
        </para>
      </section>

      <section id="using-java-api-env-token-set">
        <title>Token Set Environment</title>
        <para>
          When working with token sets, there are two environments available.

          <orderedlist>
            <listitem>
              <para>An environment shared by all tokens in the token set</para>
            </listitem>
            <listitem>
              <para>
                An environment specific to each member index. For example, if a token set
                is generated with three members, then the first token will have index
                <literal>0</literal>, the second with have index <literal>1</literal>
                and the third will have index <literal>2</literal>. Any tokens generated
                from the first token will also have index <literal>0</literal>, until
                such point as the token set is joined and is marked complete.
              </para>
            </listitem>
          </orderedlist>

          To see how token set environments are used, take as an example an approval process.
          The token set is generated as follows:

        </para>
         <programlisting><![CDATA[
Map<String,List<?>> initialMemberEnv = new HashMap<String, List<?>>();
String[] groups = new String[] { "Accounting",
                                 "Security",
                                 "Operations" };
initialMemberEnv.put( "group", Arrays.asList( groups ) );

Env tokenSetEnv = new MapEnv();
tokenSetEnv.setAttribute( "deadline", 3 );

engine.completeWithNewTokenSet(
    token,           // the token being completed
    Arc.DEFAULT_ARC, // the name of the arc(s) to exit on
    "approvals",     // name to give the new token set
    3,               // number of tokens to generate on each arc
                     // with the given name
    true,            // completing asynchronously
    tokenSetEnv,     // initial token set env
    initialMemberEnv // token set member env
  );
]]>
         </programlisting>
         <para>
           This generates a token set with three tokens in it. They all share a common <literal>deadline</literal>
           attribute, but each will see a different value for the <literal>group</literal> attribute. These
           attributes can be access from the tokens in the token set as follows:
         </para>
         <programlisting>
<![CDATA[
// Access the token set environment
Env setEnv = token.getTokenSet( "approvals" ).getEnv();
int deadline = setEnv.getAttribute( "deadline", Integer.class );

// Access the environment specific to this token within the token set
Env env = token.getTokenSetMember( "approvals" ).getEnv();
String group = env.getAttribute( "group" );
]]>
         </programlisting>
      </section>
      <section id="using-java-api-env-externals">
        <title>Externals Environment</title>
        <para>
          When defining an external in a process definition, attributes may be defined
          for that external. Those attributes will be visible to nodes in the referenced
          external.

          In the following process definition, when node <literal>A</literal> is executed,
          it will print out the values defined for attributes named <literal>foo</literal>
          and <literal>bar</literal>. If the process definition were executed directly,
          both values would be undefined.

          <programlisting>
<![CDATA[
<process-definition
  name="external-env-one"
  xmlns="http://sarasvati.googlecode.com/ProcessDefinition">

  <node name="A" type="script">
    <custom>
      <execute type="js">
        var env = token.getNode().getExternalEnv();
        System.out.println( "foo: " + env.getAttribute( "foo" ) );
        System.out.println( "bar: " + env.getAttribute( "bar" ) );
      </execute>
    </custom>
  </node>
</process-definition>
]]>
           </programlisting>

           Process definition <literal>external-env-one</literal> can be included in <literal>external-env-two</literal>,
           as demonstrated below. If executed, <literal>foo</literal> would now have the value
           <literal>hello</literal> and <literal>bar</literal> would have the value <literal>world</literal>.
          <programlisting>
<![CDATA[
<process-definition
  name="external-env-two"
  xmlns="http://sarasvati.googlecode.com/ProcessDefinition">

  <node name="B">
    <arc external="one" to="A"/>
  </node>

  <external name="one" processDefinition="external-env-one">
    <custom>
      <foo>hello</foo>
      <bar>world</bar>
    </custom>
  </external>

</process-definition>
]]>
          </programlisting>
          The values defined for externals can be overriden. This can happen when the proces definition which
          defines the external is itself references as an external, as below. Now, <literal>foo</literal>
          will have the value <literal>goodbye</literal>, while <literal>bar</literal> will retain the
          value <literal>world</literal>.
          <programlisting>
<![CDATA[
<process-definition
  name="external-env-three"
  xmlns="http://sarasvati.googlecode.com/ProcessDefinition">

  <node name="C" isStart="true">
    <arc external="two" to="B"/>
  </node>

  <external name="two" processDefinition="external-env-two">
    <custom>
      <foo>goodbye</foo>
    </custom>
  </external>

</process-definition>
]]>
          </programlisting>
        </para>
      </section>
    </section>
    <section id="using-java-api-listeners">
      <title>Execution Listeners</title>
      <para>
        It is often useful to have a callback mechanism for various events in the execution of the
        workflow. Sarasvati allows registering listeners either globally or per-process. Support
        for specifying listeners per-graph will be forthcoming.
      </para>
      <para>
        Execution listeners must implement the
        <ulink url="../../javadoc/com/googlecode/sarasvati/event/ExecutionListener.html">ExecutionListener</ulink>
        interface. Because execution listeners may be added to processes that are serialized to a database,
        there are some rules around how they should be built.
        <orderedlist>
          <listitem>
            <para>
              Execution listeners are stored in the database simply by classname.
              They must therefore have a public default constructor.
            </para>
          </listitem>
          <listitem>
            <para>
              Instances of an execution listeners may be shared across threads and should therefore
              be thread-safe. For performance reasons, they should ideally be stateless, allowing
              them to be unsychronized.
            </para>
          </listitem>
        </orderedlist>

        Here is an example listener which prints out events as they occur.

        <programlisting>
<![CDATA[
package com.googlecode.sarasvati.example;

import com.googlecode.sarasvati.event.EventActions;
import com.googlecode.sarasvati.event.ExecutionEvent;
import com.googlecode.sarasvati.event.ExecutionListener;

public class LoggingExecutionListener implements ExecutionListener
{
  @Override
  public EventActions notify (final ExecutionEvent event)
  {
    System.out.println( event.getEventType() + ": " +
                        " Process: " + event.getProcess() +
                        " NodeToken: " + event.getNodeToken() +
                        " ArcToken: " + event.getArcToken() );
    return null;
  }
}
]]>
        </programlisting>

         This listener could be register for all processes as follows:

        <programlisting>
<![CDATA[
// Add listener for all event types
engine.addExecutionListener( LoggingExecutionListener.class );

// Add listener for only the arc token and node token completed events
engine.addExecutionListener( LoggingExecutionListener.class,
                             ExecutionEventType.ARC_TOKEN_COMPLETED,
                             ExecutionEventType.NODE_TOKEN_COMPLETED );
]]>
        </programlisting>

         One can also specify a particular process to listener to.

        <programlisting>
<![CDATA[
// Add listener for all event types
engine.addExecutionListener( process, LoggingExecutionListener.class );

// Add listener for only the arc token and node token completed events
engine.addExecutionListener( process, LoggingExecutionListener.class,
                             ExecutionEventType.ARC_TOKEN_COMPLETED,
                             ExecutionEventType.NODE_TOKEN_COMPLETED );
]]>
        </programlisting>

        Listeners aren't limited to a passive. In some cases they may
        affect workflow processing by returning a
        <literal>EventActions</literal> with an appropriate
        <literal>EventActionType</literal>. The actions that may be
        taken are:

        <itemizedlist>
          <listitem>
            <para>
              An execution listener may prevent a process that is
              in pending complete state from moving to complete
              state. This is to allow end of workflow processing
              to happen asynchronously.
            </para>
          </listitem>
          <listitem>
            <para>
              Similarly, an execution listener may prevent a process
              that is in pending cancel state from moving to cancelled
              state.
            </para>
          </listitem>
          <listitem>
            <para>
              An execution listener may prevent a node token that has just
              been accepted into a node from executing. This may be used
              to implement delayed node execution based on timer.
            </para>
          </listitem>
        </itemizedlist>

        Here is a listener that creates and returns <literal>EventActions</literal>.

        <programlisting>
<![CDATA[
public class DelayExecutionListener implements ExecutionListener
{
  @Override
  public EventActions notify (final ExecutionEvent event)
  {
    if ( event.getEventType() ==
         ExecutionEventType.PROCESS_PENDING_COMPLETE )
    {
      return new EventActions(
        EventActionType.DELAY_PROCESS_FINALIZE_COMPLETE );
    }
    return null;
  }
}
]]>
        </programlisting>
      </para>
    </section>
    <section id="using-java-api-backtracking">
      <title>Backtracking</title>
        <para>
          In graph based workflow, execution proceeds forward from node to node
          along directed arcs. However, it happens that we wish to allow
          execution to return to nodes where it has already been. Sometimes
          this is done because some action needs to be performed repeatedly.
          Other times, it's because something has gone wrong, and we need to
          go back to an earlier point to fix things and go back through the
          process. Here we focus primarily on the second case, and look at
          different ways of accomplishing this.
        </para>

        <section id="using-java-api-backtracking-linear">
          <title>Linear Backtracking</title>
          <para>
            Here is a simple, linear workflow:

            <figure>
              <title>Linear Process Definition</title>
              <graphic fileref="../images/backtrack-graph1.jpg" />
            </figure>

            In this case, there is only one progression that can be made. Using
            squares for node tokens and triangles for arc tokens, the resulting
            execution looks like:

            <figure>
              <graphic fileref="../images/backtrack-process1.jpg" />
            </figure>

            What if we wish to let a user choose to send the workflow backwards,
            instead of forwards, say to fix a mistake made earlier. If we
            wanted to be able to go back, we'd have to set up arcs going
            backwards. Assuming, we want maximum flexibility, we'd end up with
            a process definition that looked like:

            <figure>
              <title>Manual Linear Backtracking</title>
              <graphic fileref="../images/backtrack-graph2.jpg" />
            </figure>

            Now we could go from A to B to C, back to B to C to D, back to B to C to
            D and done. The execution would look like:

            <figure>
              <title>Manual Linear Backtracking: Execution</title>
              <graphic fileref="../images/backtrack-process2.jpg" scalefit="1" width="100%"/>
            </figure>

            Note that the arc tokens now display the arc name.
          </para>
          <para>
            We have gained flexibility, but at the cost of making the workflow much
            more complex. The number of arcs has tripled.

            What if instead, we could use the existing arcs? After all we know
            where we've been, and we just wish to go back to a previous good
            state. So, rather than having to make explicit arcs that go back
            to all conceivable previous states, we can just
            <emphasis>backtrack</emphasis>. In other words we can just trace our
            footsteps backwards to where we were.
          </para>

          <para>
            So, lets says we've gotten up to <emphasis>C</emphasis>. At this
            point, the process execution history looks like:

            <figure>
              <graphic fileref="../images/backtrack-process3-1.jpg" />
            </figure>

            Now we wish to backtrack to <emphasis>B</emphasis>. If we
            retrace our steps, the process history will now look like:

            <figure>
              <graphic fileref="../images/backtrack-process3-2.jpg" />
            </figure>

            Note that when we traverse arc <emphasis>2</emphasis>
            backward, it's marked in red. This is to mark that we've gone
            backwards along that arc. The node tokens on <emphasis>B</emphasis>
            and <emphasis>C</emphasis>, as well as the forward moving arc token on
            <emphasis>2</emphasis> are also marked, but in blue. This is to
            note that these actions have been backtracked. When node tokens are
            backtracked, they are given the opportunity to undo whatever work
            they did, send out notifications, or do whatever else is required.
          </para>

          <para>
            We can now move forward again, this time going up to
            <emphasis>D</emphasis>, where the process execution
            history looks like:

            <figure>
              <graphic fileref="../images/backtrack-process3-3.jpg" scalefit="1" width="100%"/>
            </figure>

            If from here, we once again wish to return to <emphasis>B</emphasis>, the
            execution history will look like:

            <figure>
              <graphic fileref="../images/backtrack-process3-4.jpg" scalefit="1" width="100%"/>
            </figure>

            Note that since we are somewhat literally retracing our steps, to
            get from <emphasis>D</emphasis> to <emphasis>B</emphasis>
            we created backwards tokens at arc <emphasis>3</emphasis>,
            node <emphasis>C</emphasis> and arc <emphasis>2</emphasis>.
            The corresponding forward tokens have been marked as
            backtracked.
          </para>

          <para>
            From here we now finish, and go to the end.
            <figure>
              <graphic fileref="../images/backtrack-process3-5.jpg" scalefit="1" width="100%"/>
            </figure>
          </para>
        </section>

        <section id="using-java-api-backtracking-split">
          <title>Backtracking Across a Split</title>

          <para>
            Let us now examine a process definition which has splits and joins.

            <figure>
              <graphic fileref="../images/backtrack-graph3.jpg" />
            </figure>

            These complicate manual backtracking a great deal.
         </para>

         <para>
          If one has multiple, concurrent node tokens active after a split,
          backtracking one of them means that all must be backtracked. The
          one which has been backtracked must out and find all incomplete
          concurrent tokens and complete them. It must also set a marker
          indicating that backtracking should occur. All the tokens must
          then first be collected by an intermediary node, which will test
          to see if a backtrack is required. It will then send execution
          forward or back based on this test.
        </para>

        <para>
          If all tokens which were generated from the split aren't collected and
          sent back as a single token then each token sent back to the split
          will generate a new set of tokens from the split. This could cause
          many duplicates to be generated.
        </para>

        <para>
          Here is an example of a graph which would be roughly equivalent to the
          previous graph, but allows manual backtracking.

          <figure>
            <title>Manual Backtracking Split/Join</title>
            <graphic fileref="../images/backtrack-graph4.jpg" />
          </figure>

          It has a great deal many more arcs, as well as a more complicated
          structure, to accommodate backtracking to the split.
        </para>

        <para>
          To see how automated backtracking would work, let us first
          progress from <emphasis>A</emphasis> to <emphasis>B</emphasis>
          to where both <emphasis>C</emphasis> and
          <emphasis>D</emphasis> are open.

          <figure>
            <graphic fileref="../images/backtrack-process4-s1.jpg" />
          </figure>

          We can now attempt to backtrack to <emphasis>B</emphasis>.

          <figure>
            <graphic fileref="../images/backtrack-process4-s2.jpg" />
          </figure>

          The engine will follow all execution history which emanated from
          <emphasis>B</emphasis> and attempt to reverse it. So we can see
          that it flows backwards from <emphasis>C</emphasis> and
          <emphasis>D</emphasis> backwards to <emphasis>B</emphasis>.
        </para>

        <para>
          If we now attempt to backtrack one more step to <emphasis>A</emphasis>,
          the execution history will look like:

          <figure>
            <graphic fileref="../images/backtrack-process4-s3.jpg" scalefit="1" width="100%"/>
          </figure>

          Though this appears to be a simple linear backtrack, it's actually
          slightly complicated. The history starting from <emphasis>A</emphasis>
          includes the backtracking we just did. So the engine must traverse
          this to get to the current active tokens and backtrack them.
        </para>

        <para>
          If instead, we were to backtrack directly from when <emphasis>C</emphasis>
          and <emphasis>D</emphasis> were open, back to <emphasis>A</emphasis>,
          the execution history would look as follows:

          <figure>
            <graphic fileref="../images/backtrack-process4-s4.jpg" scalefit="1" width="100%"/>
          </figure>

          It looks almost the same, except that the second <emphasis>B</emphasis>
          is marked as a backwards execution, since this time, we went
          straight across it, instead of stopping there, and then continuing
          backwards.
        </para>
      </section>
      <section id="using-java-api-backtracking-join">
        <title>Backtracking Across a Join</title>
        <para>
          We'll use the same process definition as we used for demonstrating
          splits.

          <figure>
            <graphic fileref="../images/backtrack-graph3.jpg" />
          </figure>

          Going back from a join is both more and less problematic than a split. A
          join can act as a split and send tokens back all of its inputs.
          However, it is very difficult to go back to just one of the
          inputs. If only one of the join inputs is reactivated, then the
          join will never fire, since it won't have all the required inputs
          available.
        </para>

        <para>
          To start off with, assume execution has proceeded to
          <emphasis>E</emphasis> and the execution history looks like:

          <figure>
            <graphic fileref="../images/backtrack-process4-j1.jpg" />
          </figure>

          If we then want to go back to when <emphasis>C</emphasis>
          was open, the process will now look like:

          <figure>
           <graphic fileref="../images/backtrack-process4-j2.jpg" scalefit="1" width="100%"/>
          </figure>

          As expected, <emphasis>C</emphasis> is now open. To do so,
          we backtracked across arc <emphasis>4</emphasis>. However,
          <emphasis>D</emphasis> is not open but there is an open arc
          token on <emphasis>5</emphasis>. We only wanted <emphasis>C</emphasis>
          open, not <emphasis>D</emphasis>. However, when <emphasis>C</emphasis>
          completes, we want <emphasis>E</emphasis> to execute again. However,
          <emphasis>E</emphasis> will only execute if there are arc tokens
          waiting on arcs <emphasis>4</emphasis> and <emphasis>5</emphasis>.
          So, we backtrack arc <emphasis>5</emphasis>, but the arc token we
          create on <emphasis>5</emphasis> is left active. Now when
          <emphasis>C</emphasis> completes, <emphasis>E</emphasis>
          will execute as it will have arc tokens on all inputs.
        </para>

        <para>
          The arc token on <emphasis>5</emphasis>, marked in yellow,
          is called a <emphasis>u-turn</emphasis> since this is what
          it does. It backtracks onto an arc, but then turns around
          and goes right back.
        </para>

        <para>
          If we complete <emphasis>C</emphasis> the process will look like:

          <figure>
            <graphic fileref="../images/backtrack-process4-j3.jpg" scalefit="1" width="100%"/>
          </figure>

          If instead of completing <emphasis>C</emphasis> we backtracked
          to <emphasis>D</emphasis> as well, the process would now look like:

          <figure>
            <graphic fileref="../images/backtrack-process4-j4.jpg" scalefit="1" width="100%"/>
          </figure>

          The u-turn arc token is now marked as backtracked and a node token
          is now active on <emphasis>D</emphasis> .
        </para>
      </section>

      <section id="using-java-api-backtracking-using">
        <title>Using Backtracking</title>
        <para>
          Backtracking is very easy to use in Sarasvati.
        </para>

        <para>
          To backtrack, invoke the <literal>backtrack(NodeToken token)</literal>
          method on your <literal>Engine</literal> instance.

          <programlisting><![CDATA[
  /**
   * Backtracks execution to the point where the given
   * node token was active. The token must be complete
   * and must not have been backtracked before. If it's
   * not complete, there isn't any point in backtracking
   * to it. If it has already been backtracked, the
   * execution has either returned to a point previous
   * to that token, or there is a newer, non-backtracked
   * token at that node now.
   *
   * @param token The destination token to backtrack to.
   */
  void backtrack (NodeToken token);
]]>
          </programlisting>

          Your custom node classes may override the <literal>isBacktrackable</literal>
          and <literal>backtrack</literal> methods on <literal>Node</literal> .
        </para>

        <para>
          <literal>Node#isBacktrackable</literal> will control whether a given invocation of
          <literal>Engine#backtrack</literal> will succeed. Sometimes, business logic may
          require that certain actions not be repeated.
        </para>

        <para>
          <literal>Node#backtrack</literal> gives a place to to undo the the
          results of your custom node logic, and/or send notifications. This
          method will not be invoked until after <literal>isBacktrackable</literal>
          has returned true for all nodes needing to be backtracked.

          <programlisting><![CDATA[
  /**
   * Returns true if the specific execution of
   * this Node by the given NodeToken can be
   * backtracked.
   *
   * @param engine The engine doing the backtracking
   * @param token The token being backtracked
   * @return True if the node can be backtracked, false otherwise.
   */
  boolean isBacktrackable (Engine engine, NodeToken token);

  /**
   * Does whatever work is necessary to backtrack
   * this execution. For example, a task node may
   * send a notification that the task has been
   * backtracked.
   *
   * @param engine The engine doing the backtracking
   * @param token The specific token being backtracked.
   */
  void backtrack (Engine engine, NodeToken token);
]]>
          </programlisting>

          Here is an example of how backtracking might be invoked. This example
          assumes we want to backtrack to an ancestor of the current token located
          at a node named <emphasis>Check Inventory</emphasis>.
          <programlisting>
<![CDATA[
  String name = "Check Inventory";
  NodeToken ancestor =
    FindNodeNamedVisitor.findFirstNamedParent( token, name );
  engine.backtrack( ancestor );
]]>
          </programlisting>
        </para>
      </section>
    </section>
    <section id="using-java-api-pdv">
      <title>Process Definition Visualization</title>

      <para>
        Sarasvati offers the ability to generate an HTML image map of
        a process definition.
        </para>

      <para>
        The most convenient way to create process definition image maps is
        to use the <literal>GraphImageMapCreator</literal> class. This is
        used in conjunction with an instance of <literal>GraphToImageMap</literal>,
        which is used to help render the image and image map.

        <itemizedlist>
          <title>GraphImageMapCreator API</title>
          <listitem>
            getMapContents() - The text which should go into a <literal>map</literal> tag
          </listitem>
          <listitem>
            getImage () - The graph image
          </listitem>
          <listitem>
            writeImageToFile() - Convenience method to write the graph image to a file
          </listitem>
        </itemizedlist>

        The <literal>GraphToImageMap</literal> provides the following
        to <literal>GraphImageMapCreator</literal>.

        <itemizedlist>
          <listitem>
            The <literal>Icon</literal> used to render each node
          </listitem>
          <listitem>
            The link for each node and arc
          </listitem>
          <listitem>
            The hover text for each node and arc
          </listitem>
          <listitem>
            A preference whether or not arc labels are rendered
          </listitem>
        </itemizedlist>

        <literal>GraphToImageMapAdapter</literal> is a implementation
        of <literal>GraphToImageMap</literal> which provides default
        implementations of each of the methods.
      </para>

      <para>
        Its use is demonstrated here, as it could be used in a JSP
        file.
        <programlisting >
<![CDATA[
<%
  String basePath =
    config.getServletContext().getRealPath( "/" );

  HibEngine hibEngine = new HibEngine( hibSession );
  GraphRepository repo = hibEngine.getRepository();
  Graph graph = repo.getLatestGraph( "embedded-task-rej" );

  GraphToImageMapAdapter helper =
    new GraphToImageMapAdapter()
  {
    public String hrefForNode (Node node)
    {
      return "javascript:alert( 'You have selected " +
             node.getName() + "' );";
    }

    public String hoverForNode (Node node)
    {
      return "Name: " + node.getName() +
             ",  Type: " + node.getType() +
             ",  Guard: " + node.getGuard() +
             ",  Is start: " + node.isStart() +
             ",  Is join: " + node.isJoin();
    }
  };

  GraphImageMapCreator imageMapCreator =
    new GraphImageMapCreator( graph, helper );
  String name =  basePath + "/test.gif";
  imageMapCreator.writeImageToFile( "gif", name );
%>

  <map name="graphMap">
    <%=imageMapCreator.getMapContents()%>
  </map>

  <div style="margin-left:10px; padding-top:10px">
    <image style="border:2px black solid"
           src="<%=request.getContextPath()%>/test.gif"
           usemap="#graphMap"/>
  </div>
]]>
        </programlisting>

          The resulting page would look something like:

        <figure>
          <title>Process Definition Visualization Screenshot</title>
          <graphic fileref="../images/graph-visualization.jpg" scalefit="1" width="100%"/>
        </figure>

      </para>
    </section>
    <section id="using-java-api-pv">
      <title>Process Visualization</title>
      <para>
        Sarasvati offers the ability to generate an HTML image map of a process.
      </para>

      <para>
        The API for process visualizations is almost exactly the same as
        that for graph visualizations. The difference is that when
        visualizing we are dealing with instances of <literal>Node</literal>
        and <literal>Arc</literal>, whereas with processes, we have instances of
        <literal>VisualProcessNode</literal> and <literal>VisualProcessArc</literal>.
        A <literal>VisualProcessNode</literal> wraps a <literal>Node</literal>
        as well as a <literal>NodeToken</literal>, which may be null, since not
        every <literal>Node</literal> may have been executed.
      </para>

      <para>
        When doing process visualization, one would use the
        <literal>ProcessImageMapCreator</literal>,
        <literal>ProcessToImageMap</literal> and
        <literal>ProcessToImageMapAdapter</literal> classes,
        rather than the graph analogues.
      </para>

      <para>
        Its use is demonstrated here, as it could be used in a JSP file.

        <programlisting><![CDATA[
<%
  String basePath =
    config.getServletContext().getRealPath( "/" );

  HibEngine hibEngine = new HibEngine( hibSession );
  GraphRepository repo = hibEngine.getRepository();
  GraphProcess process = repo.findProcess( 1 );

  final SimpleDateFormat sdf =
    new SimpleDateFormat( "yyyy-MM-dd HH:mm:ss" );

  ProcessToImageMapAdapter helper =
    new ProcessToImageMapAdapter ()
  {
    public String hrefForNode (VisualProcessNode node)
    {
      return "javascript:alert( 'You have selected " +
                                node.getNode().getName() +
                                "' );";
    }

    public String hoverForNode (VisualProcessNode node)
    {
      NodeToken token = node.getToken();
      if ( token == null )
      {
        return null;
      }
      String start = sdf.format( token.getCreateDate() );
      String end = (token.getCompleteDate() == null ?
                      "Not yet finished" :
                      sdf.format( token.getCompleteDate() ) )
      return "Started: " + start +
             " Finished: " + end;
      }
    };

    ProcessImageMapCreator imageMapCreator =
      new ProcessImageMapCreator( process, helper );
    imageMapCreator.writeImageToFile( "gif", basePath + name );
%>

  <map name="processMap">
    <%=imageMapCreator.getMapContents()%>
  </map>

  <div style="margin-left:10px; padding-top:10px">
    <image style="border:2px black solid"
           src="<%=request.getContextPath()%>/test.gif"
           usemap="#processMap"/>
  </div>
]]>
        </programlisting>

        The resulting page would look something like:

        <figure>
          <title>Process Visualization Screenshot</title>
          <graphic fileref="../images/process-visualization1.jpg" scalefit="1" width="100%"/>
        </figure>
      </para>
    </section>
    <section id="using-java-api-graph-validator">
      <title>Graph Validation</title>
      <para>
        Sarasvati allows graphs to be validated as they are constructed.
        The <ulink url="../../javadoc/com/googlecode/sarasvati/load/GraphValidator.html">GraphValidator</ulink>
        interface allows validation to be performed at two points:

        <itemizedlist>
          <listitem>
              After the process definition has been loaded into memory, but before a <literal>Graph</literal>
              has been constructed.
          </listitem>
          <listitem>
            After a <literal>Graph</literal> instance has been constructed, but before it is added to the
            <literal>GraphRepository</literal>.
          </listitem>
        </itemizedlist>

        Implementers of the <literal>GraphValidator</literal> may choose whether to validate nodes and arcs
        individually, or inspect the process definition as a whole.
      </para>
      <para>
        Implements will usually subclass
        <ulink url="../../javadoc/com/googlecode/sarasvati/load/GraphValidatorAdapater.html">GraphValidatorAdapter</ulink>,
        and only override the methods they need. Here is an example validator which looks at the guards on
        node definitions before the <literal>Graph</literal> is constructor and check the start nodes afterwards.
        <programlisting >
        <![CDATA[
public class ExampleGraphValidator extends GraphValidatorAdapter
{
  public void validateNodeDefinition (final NodeDefinition nd)
    throws SarasvatiLoadException
  {
    if ( nd.getGuard() != null && !nd.getGuard().isEmpty() )
    {
      if ( !GuardValidator.isGuardValid( nd.getGuard() )
      {
        throw new SarasvatiLoadException(
          "The guard defined for node " + nd.getName()  +
          " failed validation." );
      }
    }
  }

  public void validateGraph (final Graph graph)
    throws SarasvatiLoadException
  {
    List<? extends Node> startNodes = graph.getStartNodes();
    if ( startNodes.size() != 1 ||
        !"validate-order".equals( startNodes.get( 0 ).getType() ) )
    {
      throw new SarasvatiLoadException(
        "Process definition " + graph.getName() +
        " does not start with validte order node. " +
        "Policy dictates that all " +
        "workflows must start with a " +
        "validate order node" );
    }
  }
}
]]>
        </programlisting>

        This graph validator could now be used by passing it into the
        <literal>getLoader</literal> method of <literal>Engine</literal>
        as follows:

        <programlisting><![CDATA[
  MemEngine engine = new MemEngine();
  File basePath = new File( "./process-definitions" );
  GraphValidator val = new ExampleGraphValidator();
  GraphLoader<?> loader = engine.getLoader( val );
  loader.loadNewAndChanged( new File( basePath ) );
  GraphProcess process = engine.startProcess( "test" );
      ]]></programlisting>

      </para>
    </section>
    <!--
    <section id="using-java-api-token-sets">
      <title>Token Sets/Templates</title>
      <section id="using-java-api-token-sets-intro">
        <title>Introduction</title>
        <para>
          It is o
        </para>
      </section>
    </section>
     -->
  </section>
</chapter>